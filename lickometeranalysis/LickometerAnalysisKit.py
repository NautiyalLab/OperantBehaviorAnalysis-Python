#!/usr/bin/env python3

# This file will contain function calls used in analyzing Lickometer data. 

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc
font = {'family' : 'monospace',
        'weight' : 'bold',
        'size'   : 11}
rc('font', **font)
rc('lines', lw=2)
rc('figure', figsize=(16,12))
import natsort

# These keys are the default column names from the .ms8.txt file. 
# This dictionary is used to retype DataFrames produced in read_raw_files and gen_summary_dataframe 
retype_dict = {'PRESENTATION': 'int',
 'TUBE': 'category',
 'CONCENTRATION': 'category',
 'SOLUTION': 'category',
 'IPI': 'float',
 'LTL': 'float',
 'MAX LICKS': 'float',
 'LICKS': 'int',
 'Latency': 'float'}


##### INPUT FUNCTIONS ##### 

def read_raw_files(files):
    '''
    :PARAM files: A list of paths to raw .txt files for analysis.
    :RETURN (df_dictionary,        : A dictionary containing individual DataFrames for each animal
             interlick_intervals   : A dictionary containing interlick interval data for each animal. 
             animals)              : A list of animals. 
    '''
    
    df_dictionary = {}

    # Because of the variablility in number of licks, use a dictionary to store
    # the interlick intervals for each presentation for each animal. 
    interlick_intervals = {}


    for data_file in files:
        with open(data_file, 'r') as f:
            raw_data = f.read()

        lines = raw_data.splitlines()
        # Line 5 is the subject ID. The line format is 'Animal ID, A252', e.g.
        animal_id = lines[5].split(',')[1].strip()
        # Line 5 shows the number of presentations. 
        # The format is 'Max Number Presentations, 20', e.g. 
        presentations = int(lines[9].split(',')[1].strip())
        
        # Column Names are always in line 10. 
        cols = []
        for col in lines[10].split(','):
            cols.append(col.strip())

        df_dictionary[animal_id] = pd.DataFrame(index=range(1, presentations+1), columns = cols)
        interlick_intervals[animal_id] = {}

        # Data start on line 11 and run until 11+the number of presentations.
        for idx, line in enumerate(range(11,11+presentations), start=1):

            ###### POPULATING df_dictionary ######
            
            # Read data and simultaneously remove any extra spaces around the data.   
            sanitized_data = np.array([x.strip() for x in lines[line].split(',')])
            df_dictionary[animal_id].loc[idx] = sanitized_data
        
            # Sanitizes concentration input. 
            if df_dictionary[animal_id].loc[idx, 'CONCENTRATION'][0] == '.':
                # If the concentration is fractional, and the leading character is a decimal point, add a 0 in front of it. 
                df_dictionary[animal_id].loc[idx, 'CONCENTRATION'] = f"0{df_dictionary[animal_id].loc[idx, 'CONCENTRATION']}"


            ###### POPULATING interlick_intervals ######

            # The interlick intervals for a given presentation are contained in a line presentations+1 below the row
            # containing summary information. 
            ili_line = np.array(lines[line+presentations+1].split(','), dtype='int')
            presentation_number = ili_line[0]

            # These should always match. 
            if presentation_number == idx:
                # If they do match, you can remove the presentation number and move along.
                ilis = np.delete(ili_line, 0)
            else:
                # If they don't, it's the wrong data. 
                raise ValueError

            # It is also the case that because there are INTER-lick intervals, if an animal executed only a single lick, 
                # there will be no data here. 
            # To facilitate the use these data as timestamps later on, 
                # a 0 is inserted at the beginning of each array to reflect that.

            if int(df_dictionary[animal_id].loc[idx, 'LICKS']) > 0:
                # Do this only if the animal licked during this presentation.
                ilis = np.insert(ilis, 0, 0)

            # Save the final list to the dictionary. 
            interlick_intervals[animal_id][presentation_number] = ilis


        df_dictionary[animal_id] = df_dictionary[animal_id].astype(retype_dict)

    # Creating a variable here is done solely for readability.
    animals = sorted(list(df_dictionary.keys()))

    return df_dictionary, interlick_intervals, animals

def gen_summary_dataframe(animal_dataframes, animals, experiment_label, group_by_concentration=True):
    '''
    :PARAM animal_dataframes: A dictionary containing individual DataFrames for each animal. Generated by read_raw_files.
    :PARAM animals: a list of animal ids. 
    :PARAM grouping_criteria: A boolean that determines whether data are grouped by concentration. Defaults to True.

    :RETURN total_dataframe: A long-form dataframe summarizing the data for all animals. Each row is a presentation for a single animal. 
    :RETURN total_dataframe_by_animal: A DataFrame containing all the information of the above, but grouped using a multi-index
                                       to allow easy access to individual animal data. 
    '''

    #Determine the size of the dataframe dynamically. 
    total_presentations = sum(animal_dataframes[animal].shape[0] for animal in animals)
    
    # The columns in all dataframes should be the same, so just grab an arbitrary one. 
    cols = animal_dataframes[animals[0]].columns
    total_dataframe = pd.DataFrame(index=range(1, total_presentations+1), columns=list(cols)+['AnimalID', 'Water_Normalized_Licking'])


    idx_start = 1
    for c, animal in enumerate(animals): 
        
        # Determine the target indices to which to write: 
        len_index = animal_dataframes[animal].shape[0]
        new_index = pd.Index(range(idx_start, idx_start+len_index))
        # ...and increment idx_start for the next loop.
        idx_start = new_index[-1]+1
        # Reset the index of the individual animal's DataFrame as well because of the way 
            # that pandas deals with writing from one DataFrame to another (i.e. the indices of the source DataFrame 
            # override the indices of the target, meaning you want them to match.)
        animal_dataframes[animal].set_index(new_index, inplace=True)
        
        # Write the data.
        total_dataframe.loc[new_index, cols] = animal_dataframes[animal].loc[new_index, cols]
        total_dataframe.loc[new_index, 'AnimalID'] = animal

        # If grouping by concentrations, normalize licking by water consumption. 
        if group_by_concentration:
            avg_water_licking = animal_dataframes[animal].loc[(animal_dataframes[animal].SOLUTION=='Water')&(animal_dataframes[animal].PRESENTATION>1)
                                                          , 'LICKS'].mean() # Exclude the first presentation of water to avoid potential distortion
            total_dataframe.loc[new_index, 'Water_Normalized_Licking'] = total_dataframe.loc[new_index, 'LICKS'] / avg_water_licking

    # If grouping by TUBE, Water_Normalized_Licking is empty. 
    if not group_by_concentration:
        total_dataframe.drop('Water_Normalized_Licking', axis=1, inplace=True)
    else:
        total_dataframe.loc[:, 'Water_Normalized_Licking'] = total_dataframe.loc[:, 'Water_Normalized_Licking'].astype('float')


    total_dataframe = total_dataframe.astype(retype_dict)
    total_dataframe.to_csv('MasterDataFrame_{experiment_label}.csv')
    # Will create a multi-index of (AnimalID, Presentation #).
    # This will permit easy access to each animal's data. Because each presentation # only occurs
        # once per animal, neither sum() nor mean() will actually alter the data.  
    total_dataframe_by_animal = total_dataframe.groupby(['AnimalID', 'PRESENTATION']).mean()
    return total_dataframe, total_dataframe_by_animal



##### GRAPHING FUNCTIONS ##### 

def graph_cumulative_licks(data_frame_by_animal, animals, experiment_label):
    '''
    :PARAM data_frame_by_animal: total_dataframe_by_animal from gen_summary_dataframe()
    :PARAM animals: list of animal ids. 
    :PARAM experiment_label: The label to use for naming the produced figure.  
    :RETURN: None

    Creates a plot of each animal's cumulative licking over all presentations. 
    '''

    h_holder = []
    for animal in animals:
        x_vals = data_frame_by_animal.loc[animal, :].index
        y_vals = data_frame_by_animal.loc[animal, 'LICKS'].values.cumsum()
        H, = plt.plot(x_vals, y_vals)
        h_holder.append(H)
    plt.xlabel('Presentation #')
    plt.ylabel('Total Licks')
    plt.title('Cumulative Licks Over Session')
    plt.legend(h_holder, animals)   
    plt.savefig(f'CumulativeLickCount_{experiment_label}.png')
    plt.close('all')

def individual_graph_by_group(data_frame, animals, experiment_label, grouping_criteria='CONCENTRATION', drop_first_block=True, normalize_by_water_consumption=True):
    '''
    :PARAM data_frame: total_dataframe from gen_summary_dataframe()
    :PARAM animals: list of animal ids. 
    :PARAM experiment_label: The label to use for naming the produced figure.  
    :PARAM grouping_criteria: The category by which to group data (CONCENTRATION/TUBE).
    :PARAM drop_first_block: Determines whether to include the first block of presentations in the average.
    :PARAM normalize_by_water_consumption: Determines whether to use water-normalized licking. 
    :RETURN: None

    Creates a plot of each animal's total licking during each stimulus. 
    '''

    # Determine groups for graphing and calculate block size (if necessary) based on this. 
    groups = natsort.natsorted(set(data_frame.loc[:, grouping_criteria]))

    if drop_first_block:
        block_size = len(groups)
        # Filter out first block by only selecting rows in which the presentation number
            # is greater than the number of presentations in a block.
        data_frame = data_frame.query(f'PRESENTATION>{block_size}')

    # Group data by animal and grouping criteria in preparation for graphing.
    graphing_DF = data_frame.groupby(['AnimalID', grouping_criteria]).mean()

    if normalize_by_water_consumption:
        dv_to_graph = 'Water_Normalized_Licking'
    else:
        dv_to_graph = 'LICKS'

    h_holder = []
    for animal in animals:
        x_labels = groups
        x_vals = range(len(x_labels))

        y_vals = graphing_DF.loc[(animal, groups), dv_to_graph].values
        
        H, = plt.plot(x_vals, y_vals, marker='*')
        h_holder.append(H)

    plt.title(f'Licks at each {grouping_criteria}')

    plt.legend(h_holder, animals)
    
    plt.xticks(x_vals, x_labels)
    plt.xlabel(grouping_criteria)
    
    plt.ylabel(dv_to_graph)
    

    plt.savefig(f'Total{dv_to_graph}DuringPresentation_{experiment_label}.png')
    plt.close('all')

def summarize_licking_curve(data_frame, experiment_label, grouping_criteria='CONCENTRATION', drop_first_block=True, normalize_by_water_consumption=True): 
    '''
    :PARAM data_frame: total_dataframe from gen_summary_dataframe()
    :PARAM experiment_label: The label to use for naming the produced figure.  
    :PARAM grouping_criteria: The category by which to group data (CONCENTRATION/TUBE).
    :PARAM drop_first_block: Determines whether to include the first block of presentations in the average.
    :PARAM normalize_by_water_consumption: Determines whether to use water-normalized licking. 
    :RETURN: None

    Creates a plot of each animal's total licking during each stimulus. 
    '''

   # Determine groups for graphing and calculate block size (if necessary) based on this. 
    groups = natsort.natsorted(set(data_frame.loc[:, grouping_criteria]))

    if drop_first_block:
        block_size = len(groups)
        # Filter out first block by only selecting rows in which the presentation number
            # is greater than the number of presentations in a block.
        data_frame = data_frame.query(f'PRESENTATION>{block_size}')

    if normalize_by_water_consumption:
        dv_to_graph = 'Water_Normalized_Licking'
    else:
        dv_to_graph = 'LICKS'

    # Group data by grouping criteria in preparation for graphing.
    means = data_frame.groupby([grouping_criteria]).mean()
    sems = data_frame.groupby([grouping_criteria]).sem()
    x_vals = range(len(groups))        
    plt.errorbar(x_vals, means.loc[groups, dv_to_graph], yerr=sems.loc[groups, dv_to_graph], marker='*')

    plt.title(f'Licks at each {grouping_criteria}')
    
    plt.xticks(x_vals, groups)
    plt.xlabel(grouping_criteria)
    
    plt.ylabel(dv_to_graph)
    
    plt.savefig(f'LickingCurveSummary_{dv_to_graph}_{experiment_label}.png')
    plt.close('all')

    